<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pointillist Earth</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { display: block; }
</style>
</head>
<body>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js";

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 3;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const loader = new THREE.TextureLoader();

// ✅ ONLINE EARTH TEXTURE (no local file needed)
const earthTexture = loader.load(
  "https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg",
  () => init()
);

function init() {

  const radius = 1;
  const pointCount = 15000;

  const positions = [];
  const colors = [];

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");

  canvas.width = earthTexture.image.width;
  canvas.height = earthTexture.image.height;
  ctx.drawImage(earthTexture.image, 0, 0);

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

  for (let i = 0; i < pointCount; i++) {

    const u = Math.random();
    const v = Math.random();

    const theta = 2 * Math.PI * u;
    const phi = Math.acos(2 * v - 1);

    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.cos(phi);
    const z = radius * Math.sin(phi) * Math.sin(theta);

    positions.push(x, y, z);

    // Convert sphere → texture UV
    const lon = Math.atan2(z, x);
    const lat = Math.asin(y / radius);

    const uTex = (lon / (2 * Math.PI)) + 0.5;
    const vTex = 0.5 - (lat / Math.PI);

    const px = Math.floor(uTex * canvas.width);
    const py = Math.floor(vTex * canvas.height);

    const idx = (py * canvas.width + px) * 4;

    const r = imageData[idx] / 255;
    const g = imageData[idx + 1] / 255;
    const b = imageData[idx + 2] / 255;

    colors.push(r, g, b);
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
  geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));

  const material = new THREE.PointsMaterial({
    size: 0.015,
    vertexColors: true,
    transparent: true,
    depthWrite: false
  });

  const earth = new THREE.Points(geometry, material);
  scene.add(earth);

  // Mouse interaction
  let dragging = false;
  let prevX = 0, prevY = 0;

  window.addEventListener("mousedown", e => {
    dragging = true;
    prevX = e.clientX;
    prevY = e.clientY;
  });

  window.addEventListener("mouseup", () => dragging = false);

  window.addEventListener("mousemove", e => {
    if (!dragging) return;
    earth.rotation.y += (e.clientX - prevX) * 0.005;
    earth.rotation.x += (e.clientY - prevY) * 0.005;
    prevX = e.clientX;
    prevY = e.clientY;
  });

  function animate() {
    requestAnimationFrame(animate);
    earth.rotation.y += 0.0008;
    renderer.render(scene, camera);
  }

  animate();
}

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
